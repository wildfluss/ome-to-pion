package main

import (
	"encoding/json"
	"fmt"
	"log"
	"os"
	"strings"
	"time"

	"github.com/pion/webrtc/v4"

	// signalling https://airensoft.gitbook.io/ovenmediaengine/v/0.10.0/webrtc-publishing#signalling
	"github.com/gorilla/websocket"
)

func getCandidatesFromSDP(sDP string) []OMECandidate {
	lst := []OMECandidate{}
	for _, line := range strings.Split(sDP, "\n") {
		if strings.Contains(line, "a=candidate:") {
			c := line[2:]
			// log.Printf("c: '%s'\n", c)
			lst = append(lst, OMECandidate{
				Candidate:     c,
				SdpMLineIndex: 0, // XXX
			})
		}
		// log.Println(line)
	}
	return lst
}

type OMECandidate struct {
	Candidate     string `json:"candidate"`
	SdpMLineIndex int    `json:"sdpMLineIndex"`
}

type Offer struct {
	/* // offer from ome looks like this
	"candidates":[{"candidate":"candidate:9410258367 1 UDP 50 172.22.0.3 10004 typ host","sdpMLineIndex":0},
	{"candidate":"candidate:5378924160 1 UDP 50 185.233.95.134 10004 typ host","sdpMLineIndex":0}]
	*/
	Candidates []OMECandidate `json:"candidates"`
	Command    string         `json:"command"` // eg "offer"
	IceServers []struct {
		Credential string   `json:"credential"`
		Urls       []string `json:"urls"`
		Username   string   `json:"username"`
	} `json:"iceServers"`
	Ice_servers []struct {
		Credential string   `json:"credential"`
		Urls       []string `json:"urls"`
		User_name  string   `json:"user_name"`
	}
	Id      int                       `json:"id"`
	Peer_id int                       `json:"peer_id"`
	Sdp     webrtc.SessionDescription `json:"sdp"`
}

// h/t: https://stackoverflow.com/a/51078789
type Reply struct {
	Code  int     `json:"code"` // 200 if ok , 404 if Cannot create offer
	Error *string `json:"error"`
	*Offer
}

// https://airensoft.gitbook.io/ovenmediaengine/streaming/webrtc-publishing#signalling-protocol
type Answer struct {
	Id         int                       `json:"id"`
	Command    string                    `json:"command"`
	Sdp        webrtc.SessionDescription `json:"sdp"`
	Candidates []OMECandidate            `json:"candidates"`
}

func reflect(o Offer, c *websocket.Conn) {
	ICEServers := make([]webrtc.ICEServer, len(o.IceServers))
	for i := range o.IceServers {
		ith := o.IceServers[i]
		ICEServers[i] = webrtc.ICEServer{
			Username:   ith.Username,
			Credential: ith.Credential,
			URLs:       ith.Urls,
		}
		log.Printf("ICEServer:%+v\n", ICEServers[i])
	}

	// Everything below is the Pion WebRTC API! Thanks for using it ❤️.

	// Create a MediaEngine object to configure the supported codec
	m := &webrtc.MediaEngine{}

	// Setup the codecs you want to use.

	/* // from ome , but is this about ffmpeg stream actually? :)
	[Stream Info]
	Audio Track #1: Public Name(Audio_1) Variant Name(Audio) Bitrate(67.00Kb) Codec(6,AAC,Auto) BSF(AAC_RAW) Samplerate(22.1K) Format(s16, 16) Channel(mono, 1) timebase(1/1000)
	*/

	/* // snippet of Server.xml from ome:
	<Audio>
		<Name>opus_audio</Name>
		<Codec>opus</Codec>
		<Bitrate>128000</Bitrate>
		<Samplerate>48000</Samplerate>
		<Channel>2</Channel>
		<BypassIfMatch>
			<Codec>eq</Codec>
		</BypassIfMatch>
	</Audio>
	*/
	// https://github.com/pion/webrtc/blob/da7e76ca96eaf0eb189969762adf1450fe8ac464/mediaengine.go#L82C24-L82C27
	if err := m.RegisterCodec(webrtc.RTPCodecParameters{
		RTPCodecCapability: webrtc.RTPCodecCapability{MimeType: webrtc.MimeTypeH264, ClockRate: 90000, Channels: 0, SDPFmtpLine: "level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=42e034", RTCPFeedback: nil},
		PayloadType:        96,
	}, webrtc.RTPCodecTypeVideo); err != nil {
		log.Fatal("RegisterCodec:", err)
	} else if err := m.RegisterCodec(webrtc.RTPCodecParameters{
		RTPCodecCapability: webrtc.RTPCodecCapability{MimeType: webrtc.MimeTypeOpus, ClockRate: 48000, Channels: 2, SDPFmtpLine: "minptime=10;useinbandfec=1", RTCPFeedback: nil},
		PayloadType:        111,
	}, webrtc.RTPCodecTypeAudio); err != nil {
		log.Fatal("RegisterCodec:", err)
	}
	/*
		// Create a InterceptorRegistry. This is the user configurable RTP/RTCP Pipeline.
		// This provides NACKs, RTCP Reports and other features. If you use `webrtc.NewPeerConnection`
		// this is enabled by default. If you are manually managing You MUST create a InterceptorRegistry
		// for each PeerConnection.
		i := &interceptor.Registry{}

		// Use the default set of Interceptors
		if err := webrtc.RegisterDefaultInterceptors(m, i); err != nil {
			log.Fatal("RegisterDefaultInterceptors:", err)
		}

		// Register a intervalpli factory
		// This interceptor sends a PLI every 3 seconds. A PLI causes a video keyframe to be generated by the sender.
		// This makes our video seekable and more error resilent, but at a cost of lower picture quality and higher bitrates
		// A real world application should process incoming RTCP packets from viewers and forward them to senders
		intervalPliFactory, err := intervalpli.NewReceiverInterceptor()
		if err != nil {
			log.Fatal("NewReceiverInterceptor:", err)
		}
		i.Add(intervalPliFactory)*/

	// Create the API object with the MediaEngine
	api := webrtc.NewAPI(webrtc.WithMediaEngine(m) /*, webrtc.WithInterceptorRegistry(i)*/)

	// Prepare the configuration
	config := webrtc.Configuration{
		ICEServers: ICEServers,
	}
	// Create a new RTCPeerConnection
	peerConnection, err := api.NewPeerConnection(config)
	if err != nil {
		log.Fatal("NewPeerConnection:", err)
	}
	defer func() {
		if cErr := peerConnection.Close(); cErr != nil {
			fmt.Printf("cannot close peerConnection: %v\n", cErr)
		}
	}()
	log.Println("Created a new RTCPeerConnection")

	if _, err := peerConnection.AddTransceiverFromKind(webrtc.RTPCodecTypeAudio); err != nil {
		log.Fatal("AddTransceiverFromKind:", err)
	}

	// Create Track that we send video back to browser on
	/*outputTrack, err := webrtc.NewTrackLocalStaticRTP(webrtc.RTPCodecCapability{MimeType: webrtc.MimeTypeOpus}, "video", "pion")
	if err != nil {
		log.Fatal("NewTrackLocalStaticRTP:", err)
	}

	// Add this newly created track to the PeerConnection
	rtpSender, err := peerConnection.AddTrack(outputTrack)
	if err != nil {
		log.Fatal("AddTrack:", err)
	}

	// Read incoming RTCP packets
	// Before these packets are returned they are processed by interceptors. For things
	// like NACK this needs to be called.
	go func() {
		rtcpBuf := make([]byte, 1500)
		for {
			if _, _, rtcpErr := rtpSender.Read(rtcpBuf); rtcpErr != nil {
				return
			}
		}
	}()*/

	// Set the remote SessionDescription
	err = peerConnection.SetRemoteDescription(o.Sdp)
	if err != nil {
		log.Fatal("SetRemoteDescription:", err)
	}

	// Set a handler for when a new remote track starts, this handler copies inbound RTP packets,
	// replaces the SSRC and sends them back
	peerConnection.OnTrack(func(track *webrtc.TrackRemote, receiver *webrtc.RTPReceiver) {
		fmt.Printf("Track has started, of type %d: %s \n", track.PayloadType(), track.Codec().MimeType)
		for {
			// Read RTP packets being sent to Pion
			_, _, readErr := track.ReadRTP()
			if readErr != nil {
				log.Fatal("ReadRTP:", readErr)
			}

			/*if writeErr := outputTrack.WriteRTP(rtp); writeErr != nil {
				panic(writeErr)
			}*/
		}
	})

	// Set the handler for Peer connection state
	// This will notify you when the peer has connected/disconnected
	peerConnection.OnConnectionStateChange(func(s webrtc.PeerConnectionState) {
		fmt.Printf("Peer Connection State has changed: %s\n", s.String())

		if s == webrtc.PeerConnectionStateFailed {
			// Wait until PeerConnection has had no network activity for 30 seconds or another failure. It may be reconnected using an ICE Restart.
			// Use webrtc.PeerConnectionStateDisconnected if you are interested in detecting faster timeout.
			// Note that the PeerConnection may come back from PeerConnectionStateDisconnected.
			fmt.Println("Peer Connection has gone to failed exiting")
			// os.Exit(0)
		}

		if s == webrtc.PeerConnectionStateClosed {
			// PeerConnection was explicitly closed. This usually happens from a DTLS CloseNotify
			fmt.Println("Peer Connection has gone to closed exiting")
			// os.Exit(0)
		}
	})

	// Create an answer
	answer, err := peerConnection.CreateAnswer(nil)
	if err != nil {
		log.Fatal("CreateAnswer:", err)
	}

	// Create channel that is blocked until ICE Gathering is complete
	gatherComplete := webrtc.GatheringCompletePromise(peerConnection)

	// Sets the LocalDescription, and starts our UDP listeners
	if err = peerConnection.SetLocalDescription(answer); err != nil {
		log.Fatal("SetLocalDescription:", err)
	}

	// https://github.com/pion/webrtc/blob/master/gathering_complete_promise_example_test.go#L55C2-L55C34
	// compute the local offer again
	log.Println(*peerConnection.LocalDescription())
	/* // outputs
	ome-to-pion-webrtc-pion-1  | 2023/10/26 10:58:05 {answer v=0
	ome-to-pion-webrtc-pion-1  | o=- 2001876963261635747 1698317880 IN IP4 0.0.0.0
	ome-to-pion-webrtc-pion-1  | s=-
	ome-to-pion-webrtc-pion-1  | t=0 0
	ome-to-pion-webrtc-pion-1  | a=fingerprint:sha-256 30:9F:65:41:12:B3:0D:29:25:26:0A:E6:75:52:76:4D:16:74:A8:77:59:CC:EB:FE:30:AD:02:76:59:DF:ED:F5
	ome-to-pion-webrtc-pion-1  | m=audio 0 UDP/TLS/RTP/SAVPF 0
	ome-to-pion-webrtc-pion-1  | c=IN IP4 0.0.0.0
	ome-to-pion-webrtc-pion-1  | a=candidate:1689164903 1 udp 2130706431 172.22.0.4 45183 typ host
	ome-to-pion-webrtc-pion-1  | a=candidate:1689164903 2 udp 2130706431 172.22.0.4 45183 typ host
	ome-to-pion-webrtc-pion-1  | a=candidate:3605751344 1 udp 16777215 1.1.1.1 14090 typ relay raddr 172.22.0.4 rport 47994
	ome-to-pion-webrtc-pion-1  | a=candidate:3605751344 2 udp 16777215 1.1.1.1 14090 typ relay raddr 172.22.0.4 rport 47994
	ome-to-pion-webrtc-pion-1  | a=end-of-candidates
	ome-to-pion-webrtc-pion-1  |  0x400022aa20}
	*/

	var oMEAnswer Answer = Answer{
		Id:         o.Id,
		Command:    "answer",
		Sdp:        *peerConnection.LocalDescription(),
		Candidates: getCandidatesFromSDP(peerConnection.LocalDescription().SDP),
	}
	b, err := json.Marshal(oMEAnswer)
	if err != nil {
		log.Fatal("Marshal:", err)
	}
	log.Printf("oMEAnswer json: %+v\n", string(b))
	err = c.WriteMessage(websocket.TextMessage, b)
	if err != nil {
		log.Fatal("WriteMessage:", err)
		return
	}

	// Block until ICE Gathering is complete, disabling trickle ICE
	// we do this because we only can exchange one signaling message
	// in a production application you should exchange ICE Candidates via OnICECandidate
	<-gatherComplete

	log.Println("Blocking forever")
	select {}
}

func main() {
	PLAYBACK_URL := os.Args[1] // appStream := os.Args[1]

	log.Println("PLAYBACK_URL:", PLAYBACK_URL) // "appStream:", appStream)

	// ws://localhost:3333/app/fixme

	c, _, err := websocket.DefaultDialer.Dial(PLAYBACK_URL, nil) // u.String(), nil)
	if err != nil {
		log.Fatal("dial:", err)
	}
	// defer c.Close()

	b, err := json.Marshal(struct {
		Command string `json:"command"`
	}{
		Command: "request_offer",
	})
	if err != nil {
		log.Fatal("Marshal:", err)
	}

	var reply Reply
	for {
		err = c.WriteMessage(websocket.TextMessage, b)
		if err != nil {
			log.Fatal("WriteMessage:", err)
			return
		}

		_, message, err := c.ReadMessage()
		if err != nil {
			log.Fatalf("read: %s, aborting\n", err)
		}

		log.Println(string(message))

		err = json.Unmarshal(message, &reply)
		if err != nil {
			log.Fatal("Unmarshal:", err)
		}

		if reply.Code != 200 {
			log.Println(*reply.Error)

			time.Sleep(200 * time.Millisecond)
			continue
		}

		break
	}
	log.Println(reply.Offer)

	reflect(*reply.Offer, c)

}
